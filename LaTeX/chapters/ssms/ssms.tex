%ssms

\documentclass[../../main/main.tex]{subfiles}




\begin{document}
\title{Secure State Machine Model}

%%%%%%%%%%%%%%%%%%%%% Chapter SSM Model %%%%%%%%%%%%%%%
\chapter{Secure State Machine Model}\label{chp:ssmmodel}

      %%%%%%%%%%%%%%%%%%% Section State Machines %%%%%%%%%%%%%
\section{State Machines}\label{sec:sm}
State machines are models of systems.  They use \textit{states} and \textit{transitions} among states to describe the system's behavior.  To use the state machine model for a system the system must be describable as states which can change based on some input.    

There are several models of state machines.  A discussion of these models in beyond the scope of this master thesis.  The state machine model described in this master thesis changes states and outputs based on input.  This means that some input will cause the state machine to change states and produce an output.

\subsection{States}
States of a state machine can be nearly anything.  For example, the state for a based could be described by the number of people on base.  If a soldier is permitted to enter the base, then the state of the base increases from n people to n + 1 people. Or, the state of a soldier requesting access to a base could be ``not granted" or ``granted."

In this master thesis, states are phases of the patrol base operations.  For example, figure \ref{pbtoplevel2} shows the top level diagram depicting 6 abstract phases of the patrol base operations.  These abstract phases are the states of the top level state machine.

\begin{figure}[h]
\includegraphics[width=\textwidth]{../figures/pbtoplevel}
\caption{\label{pbtoplevel2}A diagram of the most abstract level in the hierarchy of secure state machines.  Image generated by Jesse Nathaniel as part of the research involved in this master thesis.}
\end{figure}


\subsection{Transition Commands}
Transition commands are inputs to the state machine.  These inputs determine the next-state (and next-output) of the state machine.  To continue with the examples above, input for the transition from n people to n + 1 people could be ``access granted."  This same input could be used to change a soldier's state from ``not granted" to ``granted."

In this master thesis, commands indicate the next state.  For example, in figure \ref{pbtoplevel2}, transition from the Move to Objective Rally Point (ORP) state to the ORP state is indicated by the command ``conductORP."

\subsection{Next-state Function}
The next-state function describes the next state of the state machine given the current state and input.  The function call is denoted  \[ \text{\textit{NS CURRENT_STATE input }}\]For example, the next-state function to change from the n to n + 1 state would look like this: \[\text{\textit{NS N accessGranted = N + 1}}\].  Similarly, for the soldier: \[\text{\textit{NS NOT_GRANTED accessGranted = GRANTED}}\].

In this master thesis, the next-state function contains the line \[\text{\textit{NS MOVE_TO_ORP conductORP = CONDUCT_ORP}}\]

\subsection{Next-output Function}
The next-output function describes the next output of the state machine given the current state and input.  This function call is denoted  \[\text{\textit{NOut CURRENT_STATE input}}\] For example, the next-output function to change from the n to n + 1 state may look like this: \[\text{\textit{NOut N accessGranted = BasePopulationIncreasedByOne}}\].  Similarly, for the soldier: \[\text{\textit{NOut NOT_GRANTED accessGranted = NowOnBase}}\].

In this master thesis, the next-output function contains the line \[\text{\textit{NS MOVE_TO_ORP conductORP = ConductORP}}\]

\subsection{Configuration}
A configuration describes the state machine using input and output streams \cite{certmanual}. A configuration has there components: (1) current state, (2) a list of inputs (input stream), and (3) a list of outputs (output stream). The information in the configuration is sufficient to instruct the state machine's next behavior.

\subsection{TR Relations}
Transition relations define the behavior of the state machine based on its input, configuration, and the next configuration.  TR (transition relation) takes an input, an initial configuration, and a final configuration.  This should be thought of as a proposition\footnote{Proposition are necessary for proving properties of the state machine.  In the case of transitions, they can be proved to be either true or false.}?  For example, given the input and the initial configuration does the final configuration follow?  If so, then the proposition is true.  Otherwise, it is false.  A TR definition using configurations is shown below.

TR input\\
CFG \\
\hspace{1cm}input::inputList\\
\hspace{1cm}CURRENT_STATE\\
\hspace{1cm}outList\\
CFG\\
\hspace{1cm}inputList\\
\hspace{1cm}(NS input CURRENT_STATE)\\
\hspace{1cm}(NOut input CURRENT_STATE )::output


CFG denotes that what follows are the configuration components.  The first configuration is before transition and the second configuration is after.  The second configuration has the next-state, the next input (in the input stream) and the next-output as components.  

The input stream n the first configuration is a list. The double colons (::) separate the first element of the list (head) from the remainder of the list.  Using an input stream, the next configuration can be defined using the remainder of the input stream (which could be the empty list) inputList as its input. 

The state in the first configuration is just the current state.  The next state in the final configuration is the result of the next-state function \textit{NS input CURRENT_STATE}.

The output in the first configuration is the outputList.  It's head should be the output that corresponds to the current state.  The output in the final configuration is the result of the next-output function cons'd onto the front of the outputList.

TR relations with configurations form the basis for the \glsentryshort{hol} representation of state machines, which is a precursor to the secure state machines implemented in this master thesis.  


      %%%%%%%%%%%%%%%%%%% Section Secure State Machines %%%%%%%%%
\section{Secure State Machines}\label{sec:ssm}
Secure state machines add a level of security to the state machine model.  In particular, the secure state machine implements access control by way of complete mediation.   

\subsection{State Machine Versus Secure State Machine}
State machines define states, inputs, outputs, next-state functions, and next-output functions.  Through these means, the state machine defines it's behavior.  Secure state machines add the additional concept of complete mediation to the state machine model by including checks on authentication and authorization.  These checks are performed by a monitor.  A diagram showing the relationship between state machine and secure state machine with a monitor is shown in figure \ref{smVSssm}.  

\begin{figure}[!h!]
\centering
\includegraphics[width=0.8\textwidth]{../figures/smVSssm}
\caption{\label{smVSssm} State machine versus secure state machine with a monitor.  Image taken from Certified Security by Design Using Higher Order Logic \cite{certmanual}.}
\end{figure}

For this master thesis, the "Machine Instructions" represent the state machine model of the patrol base operations.


 
\subsection{Monitors}\label{monitors}
It is the duty of the monitor to control the behavior of the \glsentryshort{ssm} with regards to complete mediation.  The monitor is a essentially a guard that checks for the proper authentication and authorization for all \glsentryshort{ssm} transition requests.  In a real world analogy, the monitor is the sentry at the gate who checks IDs and determines who is granted access to the base.  In the \glsentryshort{ssm}, the monitor controls access to state machine transitions in the same manner.

\subsection{Transition Types}
The monitor assigns a transition type to each command (or \glsentryshort{ssm} transition request). This assignment is based on the security policy and the rules for authentication.  There are three transition types: execute (\textit{exec}), trap, (\textit{trap}), and discard (\textit{discard})\footnote{The names are derived from their use in virtual machines.  Commands in virtual machines are either executed, trapped, or discarded.  Each has a different behavior in the machine.}.  

\subsubsection{\textit{exec}}
The \textit{exec} transition type indicates that a command should be executed.  For example, if the Platoon Leader issues the command (request) \textit{crossLD}, then the monitor must first check the authentication and authorization for that request.  If the monitor authenticates the Platoon Leader and authorizes her on that request, then the monitor can justify executing that request.  In the \glsentryshort{ssm} model, this means that the transition from the PLAN_PB state to the MOVE_TO_ORP state (indicated by the command \textit{crossLD}) should be allowed. 
\subsubsection{\textit{trap}}
The \textit{trap} transition type indicates that a command should NOT be executed.  The \textit{trap} transition type indicates that the principal is authenticated, but NOT authorized on that command.  For example, if the Platoon Leader issues the command \textit{initiateMovement}, then the monitor must first check the authentication and authorization of that request.  In this case, the monitor authenticates the Platoon Leader.  But, the monitor does not authorize the Platoon Leader on the command \textit{initiateMovement} because only the Platoon Sergeant is authorized on this command.  In the \glsentryshort{ssm} model, this means that the transition from the WARNO state to the REPORT1 state (partially indicated by \textit{initiateMovement}) should NOT be allowed.  It should be trapped.


\subsubsection{\textit{discard}}
Like the \textit{trap} transition type, the \textit{discard} transition type indicates that the command should NOT be executed.  The \textit{discard} transition type indicates that the principal is neither authenticated nor authorized.  It may also indicate that the command is not of the correct form. For example, if SomeGuy issues \textit{anyCommand}, the monitor must first check the authentication and authorization for that request. If the monitor does not authenticate SomeGuy, then SomeGuy's command is discarded.

It is useful to differentiated between the \textit{trap} and \textit{discard} transition types.  This allows for the behavior of the \glsentryshort{ssm} to handle authenticated but unauthorized and un-authenticated and unauthorized commands differently.  For example, a sentry may choose to deny access to someone who is authenticated but unauthorized.  On the other hand, a sentry may choose to detain an unauthenticated person.

\subsection{Commands}
Commands in the \glsentryshort{ssm} are handled differently than in the state machine.  Principals issue commands (make requests).  The monitor inspects the command (request) for proper authentication and authorization and assigns a transition type to the command (request).  This combination of transition type and command (request) is then passed to the next-state and next-output functions.  These functions define how the \glsentryshort{ssm} responds to each transition type and command (request) pair.  This differs from the state machine in that the state machine only defines next-state and next-output functions for commands.  The state machines is not concerned with authentication and authorization (i.e., access-control).

For example, the \glsentryshort{ssm} for the top level is shown in figure \ref{ssmPBDiagram2} (this is the same as figure \ref{ssmPBDiagram} in section \ref{ssec:toplevel}).  

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{../figures/ssmPBDiagram}
\caption{\label{ssmPBDiagram2} Top level diagram.}
\end{figure}

In the state machine, the transition from PLAN_PB to MOVE_TO_ORP only requires the command \textit{crossLD}.  But, in the secure state machine, transitions require some form of access-control.  Transitions are indicated by principals making requests of the form \textit{SomePrincipal says someCommand}.  In figure \ref{ssmPBDiagram2}, the Platoon Leader makes a request (issues a command) to transition from the PLAN_PB state to the MOVE_TO_ORP by stating 
 \[\textit{PlatoonLeader says crossLD}.\]

The monitor then checks the authentication and authorization of the principal and returns the command with a transition type.  For example, if the Platoon Leader is both authenticated and authorized on the command \textit{crossLD}, then the monitor returns the transition type and command pair 
\[exec \hspace{0.2cm} crossLD\]

This is passed to the next-state and next-output functions.  The next-state function is then justified in executing the transition from the PLAN_PB state to the MOVE_TO_ORP state.  

\subsection{Authentication}
Authentication in the \glsentryshort{ssm} refers to verification of identity.  Authentication is a very broad topic and details are beyond the scope of this master thesis.  

In this master thesis, authentication is dealt with by simple visual confirmation of a principal's identity\footnote{Although, other methods are discussed in the chapter \ref{chp:other}, particularly with regards to accountability systems.}.  This was justified by assuming that most soldiers in the platoon should recognize their leaders.

Authentication is verified by the monitor on each request\footnote{In the implementation of the \glsentryshort{ssm}, this may or may not be the case.  For example, access to a secured facility may require proper authentication upon entering the facility.  This may be indicated with by a badge worn by the individual while in the facility.  Within the facility, only badges are checked.  But, the process of verifying identity only occurs at the entry.}.  This means that each request must be of the form \textit{SomePrincipal says someCommand}, even if the principal was previously authenticated.  

\subsection{Authorization}
Authentication is a way of controlling who has access to what by means of a security policy.  The security policy implements the principal of complete mediation (and other security policies).  

Authentication in the \glsentryshort{ssm} is typically one or more functions that define which principals have control over which transitions.  A simple authorization in a \glsentryshort{ssm} is \textit{SomePrincipal controls someCommand}.    Using the access-control logic (ACL) described in Chapter \ref{chp:csbdacl} and a request of the form \textit{SomePrincipal says someCommand}, \textit{someCommand} is justified.  Of course, the monitor must first check the authentication of SomePrincipal.  Once that is verified, the monitor returns the transition type and command pair \textit{exec someCommand}.

Authorization is often more complicated.  For example, there are two security policies for the top level \glsentryshort{ssm} shown in figure \ref{ssmPBDiagram2}.  The security policy for the Omni principal is
\[\text{\textit{Omni controls omniCommand}}.\]  This means that the Omni principal is authorized on any omniCommand.  For example, \textit{ssmPlanPBComplete} is one \textit{omniCommand} in the top level \glsentryshort{ssm} in figure \ref{ssmPBDiagram2}.  The security policy for the Platoon Leader depends on the current state because the Platoon Leader is only authorized to transition to the next state if the current state is complete.  (Omni indicates when the current state is complete.)  Thus, the security policy for the Platoon Leader on the transition from the PLAN_PB state to the MOVE_TO_ORP state in figure \ref{ssmPBDiagram2} has the form \[\text{\textit{ssmPlanPBComplete impf PlatoonLeader controls crossLE}}\]where \textit{impf} is the \glsentryshort{acl} operator for implication.

\subsection{Next-state And Next-output Functions}
The next-state and next-output functions define the behavior for the \glsentryshort{ssm}.  Whereas the behavior of the state machine is defined only for states and commands, the behavior in the \glsentryshort{ssm} includes the behavior for each transition type in combination with each command.  This means that for each command, the next-state and next-output functions define three separate behaviors: \textit{exec someCommand}, \textit{trap someCommand}, and \textit{discard someCommand}.  

\subsection{Configurations}
The configuration in the secure state machine adds three additional components, for a total of six: (1) an authentication function, (2) a state interpretation function (a state-dependent security policy), (3), a security context, (4) an input list (a command list), (5) a state, and (6) an output list.   The next-state and next-output functions are not part of the configuration because they define the permanent structure of the \glsentryshort{ssm}.

\subsection{TR Relations}
Transition relations in the secure state machine are similar to those for the state machine.  

TR (trTpye input)\\
CFG \\
\hspace{1cm}authenticationTest\\
\hspace{1cm}stateInterpretation\\
\hspace{1cm}securityContext\\
\hspace{1cm}input::inputList\\
\hspace{1cm}CURRENT_STATE\\
\hspace{1cm}outList\\
CFG\\
\hspace{1cm}authenticationTest\\
\hspace{1cm}stateInterpretation\\
\hspace{1cm}securityContext\\
\hspace{1cm}inputList\\
\hspace{1cm}(NS (tyType input) CURRENT_STATE)\\
\hspace{1cm}(NOut (trType input) CURRENT_STATE )::output

In addition to the three additional components, the transition type (trType) is added to the front of the input.  Because the next-state and next-output functions are defined in terms of the transition type and command pair, the trType is also used in these functions.   

The authenticationTest, stateInterpretation, and securityContext functions are the same in both the initial and final configurations.

\subsection{Configuration Interpretation}
The TR relation is a proposition that returns true or false based on whether the second configuration follows from the first.  But, this is not wholly sufficient to prove complete mediation.  Complete mediation requires that the configuration be interpreted in the context of authentication and authorization.

ConfigurationInterpretation\\
\hspace{1cm}(M,Oi,Os)\\
\hspace{1cm}CFG\\
\hspace{2cm}AuthenticationTest inputOK\\
\hspace{2cm}StateInterpretation \\
\hspace{2cm}SecurityContext\\
\hspace{2cm}input::inputList\\
\hspace{2cm}CURRENT_STATE\\
\hspace{2cm}outList\\
\hspace{1cm}\HOLSymConst{\HOLTokenEquiv{}}\\
\hspace{1cm} M,Oi,Os) satisfies (securityContext, input, and stateInterpretation)

In the broadest sense, this function says that the configuration interpretation is true if and only if the securityContext, input, and stateInterpretation satisfy the Kripke structure (M,Oi,Os).  

This configuration interpretation function takes a Kripke structure and the initial configuration as parameters. The Kripke structure is necessary to prove properties of soundness.  But, Kripke structures are not used in this master thesis.  Nevertheless, soundness is true for ALL Kripke structures.  Thus it is sufficient to pass any undefined Kripke structure\footnote{Remember that the Kripke structure in the \glsentryshort{hol} implementation of the \glsentryshort{csbd} has a Kripke structure is of the form (M, Oi, Os).}.  

In practice, the last line of the configurationInterpretation function is reduced for \textit{exec} and \textit{trap} transition types.

\hspace{1cm} (M,Oi,Os) satisfies someCommand\\
\hspace{1cm} (M,Oi,Os) satisfies noCommand

where someCommand means that execution of the input command is justified and noCommand means that the command is trapped.  Details depend on the implication and use the Option datatype, described in the section \ref{option} below.  The \textit{discard} transition type does not require configurationInterpretation because the command does not pass the authentication phase.



      %%%%%%%%%%%%%%%%%%% Section SSMs in HOL %%%%%%%%%%%%%
\section{Secure State Machines in HOL}\label{sec:sminHOL}
The secure state machines are implemented in \glsentryshort{hol}.  This section describes the components of the parametrizable secure state machine (denoted "ssm" with lower-case letters).

\subsection{Parameterizable Secure State Machine}
ssm is implemented as a parametrizable secure state machine. Parametrization allows for re-use of common definitions and theorems in the \glsentryshort{ssm} model.  The parametrizable components are
\begin{itemize}
\item Next-state function
\item Next-output function
\item Input \& Input stream
\item Output \& Output stream
\item States
\item Principals
\item Security context
\item State interpretation-based security context
\item Authentication test function
\end{itemize}

To use the ssm, the rule ISPECL \glsentryshort{hol} is used to specialize the parametrizable theorems for a specific secure state machine. 

\subsection{Input Stream}
The input to the secure state machines is in the form of a list of inputs (an input stream).  Elements in the list are of the form \textit{P says prop (SOME cmd)}.  It is necessary to extract particular components from the list and list elements.  Several functions are defined to do this.  These are essentially helper functions.

\paragraph*{extractCommand}
extractCommand takes one input of the form \textit{P says prop (SOME cmd)} and extracts the \textit{cmd} part.

\HOLThmTag{ssm}{extractCommand_def}\HOLssmTheoremsextractCommandXXdef


\paragraph*{commandList}
commandList takes an input list consisting of list elements of the form \textit{P says prop (SOME cmd)}.  It returns a list of all the \textit{cmd} elements.
\begin{tabbing}
\parskip=8pt
\HOLTokenTurnstile{} \HOLSymConst{\HOLTokenForall{}}\HOLBoundVar{x}. \\
\hspace{0.3cm} \HOLConst{commandList} \HOLBoundVar{x} \HOLSymConst{=} \HOLConst{MAP} \HOLConst{extractCommand} \HOLBoundVar{x}
\parskip=18pt
\end{tabbing}

\paragraph*{extractPropCommand}
extractPropCommand takes one input of the form \textit{P says prop (SOME cmd)} and extracts the \textit{prop (SOME cmd)} part.

\HOLThmTag{ssm}{extractPropCommand_def}\HOLssmTheoremsextractPropCommandXXdef


\paragraph*{propCommand}
propCommand takes an input list consisting of list elements of the form \textit{P says prop (SOME cmd)}.  It returns a list of all the \textit{prop (SOME cmd)} elements.
\begin{tabbing}
\parskip=8pt
\HOLTokenTurnstile{} \HOLSymConst{\HOLTokenForall{}}\HOLBoundVar{x}. \\
\hspace{0.3cm} \HOLConst{propCommandList} \HOLBoundVar{x} \HOLSymConst{=} \HOLConst{MAP} \HOLConst{extractPropCommand} \HOLBoundVar{x}
\parskip=18pt
\end{tabbing}


\paragraph*{extractInput}
extractInput takes one input of the form \textit{P says prop x} and extracts the \textit{x} part. Note that \textit{x} can have two forms: \textit{NONE} or \textit{SOME cmd}.

\HOLThmTag{ssm}{extractInput_def}\HOLssmTheoremsextractInputXXdef


\paragraph*{inputList}
inputList takes an input list consisting of list elements of the form \textit{P says prop x}.  It returns a list of all the \textit{x} elements.
\begin{tabbing}
\parskip=8pt
\HOLTokenTurnstile{} \HOLSymConst{\HOLTokenForall{}}\HOLBoundVar{xs}. \\
\hspace{0.3cm} \HOLConst{inputList} \HOLBoundVar{xs} \HOLSymConst{=} \HOLConst{MAP} \HOLConst{extractInput} \HOLBoundVar{xs}
\parskip=18pt
\end{tabbing}


\subsection{Commands}
\paragraph*{Option Type}\label{option}
The option type allows for the return of "no value."  In functional programming, this is an important concept because functions must always return a value.  Consider the following example.
An association list consists of tuples of the form \{('a',1), ('b',2), ... (a,26)\}. A search for 1 returns the integer value 'a'.  But, what if the target of the search is the number 27?  The search must return something.  But, there is nothing to return.  This is where the option type comes in handy.  Instead of returning 'a' for 1 and 'b' for 2 and so on, the search returns SOME 'a' and SOME 'b' and so on.  If the search does not find a match, it returns NONE.

The definition for the option datatype is

\HOLFreeVar{option} = \HOLConst{NONE} \HOLTokenBar{} \HOLConst{SOME} 'a

In the datatype definition above, 'a is replaced with some other datatype.  

\paragraph*{A Closer Look at Commands}
To see what this looks like in \glsentryshort{hol}, it is necessary to define some other datatypes. The OMNILevel folder in OMNITypesScript.sml contains definitions that are used in all patrol base operations \glsentryshortpl{ssm}. One definition is the \HOLFreeVar{command} datatype definition.

\begin{tabbing}
\HOLFreeVar{command} = \HOLConst{ESCc} \HOLTyOp{escCommand} \HOLTokenBar{} \HOLConst{SLc} 'slCommand
\end{tabbing}

The \HOLFreeVar{command} datatype consists of two additional datatypes: \HOLConst{ESCc} \HOLTyOp{escCommand} and \HOLConst{SLc} 'slCommand.  Note that the first part of each of these are the datatype constructors\footnote{see the background section \ref{sec:adtinml}}: \HOLConst{ESCc} and \HOLConst{SLc}.  The second part is the name of the datatype variable\footnote{Both of these are datatype variables because they define other datatypes.} or datatype.  

The first datatype refers to the escape commands.  They are defined as \HOLTyOp{escCommand} in the same file as \HOLFreeVar{command}.

 \begin{tabbing}
 \HOLFreeVar{escCommand} = \= \HOLConst{returnToBase} \\
 						\>\HOLTokenBar{} \HOLConst{changeMission} \\
						\>\HOLTokenBar{} \HOLConst{resupply}
           \HOLTokenBar{} \HOLConst{reactToContact}
\end{tabbing}

This datatype definition defines three commands (or datatype values) which represent escape conditions in the patrol base operations.  

The second dataytpe variable 'slCommand refers to the state-level commands.  These are defined further in each \glsentryshort{ssm}.  

Notice that there is a tick mark (apostrophe) before 'slCommand and not before \HOLTyOp{escCommand}.  In general, the tick mark in \glsentryshort{hol} represents an undefined dataytpe.  In this case, 'slCommand is not yet defined (because it is defined elsewhere), whereas the definition for \HOLTyOp{escCommand} is defined in the same file and above the definition for \HOLFreeVar{command}.   

An example of a definition for 'slCommand can be found in the top level \glsentryshort{ssm}.  It is defined in the folder topLevel and in the file PBIntegratedTypeScript.sml file.

\HOLFreeVar{slCommand} = \HOLConst{PL} \HOLTyOp{plCommand} \HOLTokenBar{} \HOLConst{OMNI} \HOLTyOp{omniCommand}

This is defined similarly to \HOLFreeVar{command}.  There are two datatypes that make-up the datatype \HOLFreeVar{slCommand}.  None of these have tick marks, which means both of these are defined.  In particular, they are both defined in the same file as \HOLFreeVar{slCommand}.

\HOLFreeVar{plCommand} refers to the Platoon Leader commands.  These are commands that the Platoon Leader is authorized to make.  

\begin{tabbing}
\HOLFreeVar{plCommand} = \= \HOLConst{crossLD} \\
					     \>\HOLTokenBar{} \HOLConst{conductORP} \\
					     \>\HOLTokenBar{} \HOLConst{moveToPB} \\
					     \>\HOLTokenBar{} \HOLConst{conductPB}\\
         				     \> \HOLTokenBar{} \HOLConst{completePB} \\
				             \> \HOLTokenBar{} \HOLConst{incomplete}
\end{tabbing}


\HOLFreeVar{omniCommand} refers to commands that the OMNI level principal\footnote{See section \ref{ssec:omnilevel} for a discussion of the OMNI level principal.} is authorized to make. 

\begin{tabbing}
\HOLFreeVar{omniCommand} = \= \HOLConst{ssmPlanPBComplete} \\
						 \> \HOLTokenBar{} \HOLConst{ssmMoveToORPComplete}\\
 				       	 	 \> \HOLTokenBar{} \HOLConst{ssmConductORPComplete} \\
						 \> \HOLTokenBar{} \HOLConst{ssmMoveToPBComplete}\\
            					 \> \HOLTokenBar{} \HOLConst{ssmConductPBComplete}\\
					 	 \> \HOLTokenBar{} \HOLConst{invalidOmniCommand}
\end{tabbing}          
          
          
\paragraph*{Option Type with Commands}
With these definitions, it is possible to see how the options types are used with commands (datatypes).  What follows is a list of examples using the option types and commands (datatypes) described above.  The type signatures are also included because it will help the reader recognize them in the \glsentryshort{hol} code.
\begin{description}
\item[ ] SOME (SLc (ESCc returnToBase)) \\
The type for this is (escCommand command)Option.
\item[ ] SOME (SLc (PL moveToORP))  \\
The type for this is ((plCommand slCommand) command)Option.  
\item[ ] SOME (SLc (OMNI ssmMoveToORPComplete))\\
The type for this is ((omniCommand slCommand) command)Option.  
\end{description}

Note that the constructors are necessary for each command. Also, note that in the \glsentryshort{hol} code for the patrol base operations, the reader will typically see (slCommand command)Option.  This is because the definitions require a type \HOLFreeVar{slCommand}, which includes \HOLFreeVar{plCommand}  and \HOLFreeVar{omniCommand}.




\subsubsection{Transition Types}
Transition datatypes indicate how a command is handled by the monitor.  The three transition datatypes are described below. 

\HOLFreeVar{trType} = \HOLConst{discard} 'cmdlist \HOLTokenBar{} \HOLConst{trap} 'cmdlist \HOLTokenBar{} \HOLConst{exec} 'cmdlist

The 'cmdlist refers to a list of commands of the form discussed in the section above.  For example, to execute the transition from the PLAN_PB state to the MOVE_TO_ORP state, the monitor must return the transition type and command pair with the later of the pair in the form of a list 
\[\text{\textit{exec [SOME (SLc (PL crossLD))]}} \]

where \textit{SOME (SLc (PL crossLD))} is the single item in the cmdlist.  The transition type with the command list is then passed to the next-state and next-output functions.

\subsection{Authentication}
Authorization is context dependent. But, a parametrizable authentication is defined in the parametrizable \glsentryshort{ssm}.

\begin{tabbing}
\parskip=8pt

\HOLTokenTurnstile{} \=\HOLSymConst{\HOLTokenForall{}}\HOLBoundVar{elementTest} \HOLBoundVar{x}. \\
    \> \HOLConst{authenticationTest} \HOLBoundVar{elementTest} \HOLBoundVar{x}  \HOLSymConst{\HOLTokenEquiv{}} \\
    \> \HOLConst{FOLDR} (\HOLTokenLambda{}\HOLBoundVar{p} \HOLBoundVar{q}. \HOLBoundVar{p} \HOLSymConst{\HOLTokenConj{}} \HOLBoundVar{q}) \HOLConst{T} (\HOLConst{MAP} \HOLBoundVar{elementTest} \HOLBoundVar{x})
\parskip=18pt
\end{tabbing}

This function takes an elementTest function and an input list as parameters.  The elementTest function is named inputOK and it is defined separately for each \glsentryshort{ssm}.  elementTest takes a single input of the form \textit{SomePrincipal says someCommand}.  It returns TT (the \glsentryshort{acl} representation of True) if the input is authenticated and FF otherwise.  

The authenticationTest function FOLDRs the elementTest function over the input list x with the conjunction function and True as the accumulator\footnote{This means that the elementTest function is applied to each element in the input list x, resulting in a TT or FF value for each element in the input list x.   Then, in essence, the value of the conjunction of all these values is returned.}  Thus, if all the input elements in the input list x pass the elementTest, the authenticationTest function returns true, otherwise it returns false.  
     
\subsection{Authorization}
Authorization is the security context and it is \glsentryshort{ssm}-dependent. This means that each \glsentryshort{ssm} defines its own security context.  The parametrizable \glsentryshort{ssm} allows for two ways to define the security context and pass them as parameters.  The first is the state interpretation function. This function takes a state and an input list as parameters.  It defines the security context based on state.  All state-dependent behavior may also be defined in this function.

The second function is the security context function.  It takes only the input list as a parameter.  It's definition applies to all states.

\subsection{Next-state And Next-output Functions}
The next-state and next-output functions are parameters to the parametrizable \glsentryshort{ssm}.  They are defined separately in each \glsentryshort{ssm}.  In the parametrizable \glsentryshort{ssm} they are denoted by NS and Out, respectively.

\subsection{Configurations}
Configurations in the \glsentryshortpl{ssm} have six components.  Each \glsentryshort{ssm} must define all six components to use the parametrizable ssm.  These components are:
\begin{enumerate}
\item authentication test function.  \\
The type signature is 

\hspace{0.5cm}  (('command \HOLTyOp{option}, 'principal, 'd, 'e) \HOLTyOp{Form} -> \HOLTyOp{bool})

\item state interpretation function.  \\
The type signature is
\begin{tabbing}
\hspace{0.5cm}('state -> \=('command \HOLTyOp{option}, 'principal, 'd, 'e) \HOLTyOp{Form} \HOLTyOp{list} -> \\
				      \>('command \HOLTyOp{option}, 'principal, 'd, 'e) \HOLTyOp{Form} \HOLTyOp{list}) 
\end{tabbing}
\item security context function.  \\
The type signature is 

 \hspace{0.5cm}   (('command \HOLTyOp{option}, 'principal, 'd, 'e) \HOLTyOp{Form} \HOLTyOp{list} -> \\
\hspace{0.5cm}    ('command \HOLTyOp{option}, 'principal, 'd, 'e) \HOLTyOp{Form} \HOLTyOp{list}) 

\item input list stream.  \\
The type signature is

 \hspace{0.5cm}  (('command \HOLTyOp{option}, 'principal, 'd, 'e) \HOLTyOp{Form} \HOLTyOp{list} \HOLTyOp{list}) \

\item state.  \\
The type signature is

\hspace{0.5cm}   'state

\item output stream.  \\
The type signature is 

\hspace{0.5cm} ('output \HOLTyOp{list})
\end{enumerate}

Note that the authentication test function is defined in the parametrizable ssm as authenticationTest.  This function takes one input (named elementTest in this ssm and inputOK in the \glsentryshortpl{ssm}).

These components comprise the six components of the configuration datatype (with CFG as the datatype constructor)

\begin{tabbing}
\parskip=8pt
\HOLFreeVar{configuration} = \\
\hspace{0.3cm}    \HOLConst{CFG} \\
\hspace{0.5cm}  (('command \HOLTyOp{option}, 'principal, 'd, 'e) \HOLTyOp{Form} -> \HOLTyOp{bool})\\
\hspace{0.5cm}    ('state -> ('command \HOLTyOp{option}, 'principal, 'd, 'e) \HOLTyOp{Form} \HOLTyOp{list} -> \\
\hspace{0.5cm}    ('command \HOLTyOp{option}, 'principal, 'd, 'e) \HOLTyOp{Form} \HOLTyOp{list}) \\
 \hspace{0.5cm}   (('command \HOLTyOp{option}, 'principal, 'd, 'e) \HOLTyOp{Form} \HOLTyOp{list} -> \\
\hspace{0.5cm}    ('command \HOLTyOp{option}, 'principal, 'd, 'e) \HOLTyOp{Form} \HOLTyOp{list}) \\
 \hspace{0.5cm}  (('command \HOLTyOp{option}, 'principal, 'd, 'e) \HOLTyOp{Form} \HOLTyOp{list} \HOLTyOp{list}) \\
\hspace{0.5cm}   'state \\
\hspace{0.5cm} ('output \HOLTyOp{list})
\parskip=18pt
\end{tabbing}

\subsection{Configuration Interpretation}
The monitor must interpret the configuration.  The CFGInterpret function take as input a Kripke structure and a configuration.  It returns a conjunction of three things: a satList of the security context, a satList of the input stream, and a satList of the stateInterpretation function.  

satList is a list of elements that satisfy the property of soundness as discussed in chapter \ref{chp:csbdacl} section \ref{sssec:soundness}\footnote{Note that in the \glsentryshort{acl} implementation of the "satisfies" and "soundness" properties, "satisfies" serves as "soundness" when it is generalized for all Kripke structures.}.  satList is defined in satListTheory.  

\begin{tabbing}
\parskip=8pt
\HOLTokenTurnstile{} \hspace{0.3cm}\HOLSymConst{\HOLTokenForall{}}\HOLBoundVar{M} \HOLBoundVar{Oi} \HOLBoundVar{Os} \HOLBoundVar{formList}.\\
\hspace{0.5cm}(\HOLBoundVar{M}\HOLSymConst{,}\HOLBoundVar{Oi}\HOLSymConst{,}\HOLBoundVar{Os}) \HOLConst{satList} \HOLBoundVar{formList} \HOLSymConst{\HOLTokenEquiv{}} \\
\hspace{0.5cm} \HOLConst{FOLDR} (\HOLTokenLambda{}\HOLBoundVar{x} \HOLBoundVar{y}. \HOLBoundVar{x} \HOLSymConst{\HOLTokenConj{}} \HOLBoundVar{y}) \HOLConst{T} (\HOLConst{MAP} (\HOLTokenLambda{}\HOLBoundVar{f}. (\HOLBoundVar{M}\HOLSymConst{,}\HOLBoundVar{Oi}\HOLSymConst{,}\HOLBoundVar{Os}) \HOLConst{sat} \HOLBoundVar{f}) \HOLBoundVar{formList})
\parskip=18pt
\end{tabbing}

satList MAPs the \textit{sat} operator onto each element in the formList. It then FOLDRs the formList elements with the conjunction function and accumulator True.  This means that satList applied to formList returns true if each element in the list satisfies the \textit{sat} property.

Other properties of satList can be found in appendix \ref{ppacl}.

With satList defined, the meaning of CFGInterpret should follow.  

\begin{tabbing}
\parskip=8pt
\HOLTokenTurnstile{} \HOLConst{CFGInterpret}\\
\hspace{0.5cm}(\HOLFreeVar{M}\HOLSymConst{,}\HOLFreeVar{Oi}\HOLSymConst{,}\HOLFreeVar{Os})
     (\HOLConst{CFG} \HOLFreeVar{elementTest} \HOLFreeVar{stateInterp} \HOLFreeVar{context} (\HOLFreeVar{x}\HOLSymConst{::}\HOLFreeVar{ins}) \HOLFreeVar{state}
     \HOLFreeVar{outStream}) \HOLSymConst{\HOLTokenEquiv{}} \\
\hspace{0.5cm}(\HOLFreeVar{M}\HOLSymConst{,}\HOLFreeVar{Oi}\HOLSymConst{,}\HOLFreeVar{Os}) \HOLConst{satList} \HOLFreeVar{context} \HOLFreeVar{x} \HOLSymConst{\HOLTokenConj{}} (\HOLFreeVar{M}\HOLSymConst{,}\HOLFreeVar{Oi}\HOLSymConst{,}\HOLFreeVar{Os}) \HOLConst{satList} \HOLFreeVar{x} \HOLSymConst{\HOLTokenConj{}}\\
\hspace{0.5cm}(\HOLFreeVar{M}\HOLSymConst{,}\HOLFreeVar{Oi}\HOLSymConst{,}\HOLFreeVar{Os}) \HOLConst{satList} \HOLFreeVar{stateInterp} \HOLFreeVar{state} \HOLFreeVar{x}
\parskip=18pt
\end{tabbing}


\subsection{TR Rules}\label{ssec:trrules}
The transition rules in \glsentryshort{hol} are defined in figure \ref{trrules}.

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{../figures/trrules}
\caption{\label{trrules} Transition rules in \glsentryshort{hol}.   Image taken from Certified Security by Design Using Higher Order Logic \cite{certmanual}}
\end{figure}

There are three rules, one for each transition type.  Above each line are the hypotheses and below are the conclusions.  The symbol $\text{\textit{Config}}  \xrightarrow[\text{}]{\text{exec (inputList x)}} \textit{Config}_e$ represents the TR relation for the input \textit{exec inputList x}.  Similarly, the symbols $\text{\textit{Config}}  \xrightarrow[\text{}]{\text{trap (inputList x)}} \textit{Config}_t$ and $\text{\textit{Config}}  \xrightarrow[\text{}]{\text{discard (inputList x)}} \textit{Config}_d$ represent the TR relations for \textit{trap inputList x} and \textit{discard inputList x}, respectively. 


The \textit{Execute} rule takes the authenticationTest function (with two parameters) and the CFGInterpret function (with two parameters).  If these are true, then \textit{Execute} concludes the TR relation $\text{\textit{Config}}  \xrightarrow[\text{}]{\text{exec (inputList x)}} \textit{Config}_e$.  \textit{Trap} is similar to \textit{Execute}.

The \textit{Discard} rule takes only the authenticationTest function (with two parameters).  If this is false, then the hypothesis is true.  Thus, the  $\text{\textit{Config}}  \xrightarrow[\text{}]{\text{discard (inputList x)}} \textit{Config}_d$ follows.

The definitions for the \textit{Config}s are defined below the rules. 

These definitions are defined in \glsentryshort{hol} as rule0, rule1, and rule2 (TR_discard_cmd_rule).  Notice that these are biconditionals.  The hypotheses and conclusions are reversed in the definitions below.  

\paragraph*{rule0}
\HOLThmTag{ssm}{TRrule0}\HOLssmTheoremsTRruleZero



\paragraph*{rule1}
\HOLThmTag{ssm}{TRrule1}\HOLssmTheoremsTRruleOne

\paragraph*{rule2}


\HOLThmTag{ssm}{rule2...(same as) TR_discard_cmd_rule}\HOLssmTheoremsTRXXdiscardXXcmdXXrule


\paragraph*{Complete mediation and TR Relations}
If remains to prove that complete mediation justifies execution, trapping, or discarding of commands. 

\paragraph*{TR_exec_cmd_rule}
The following function demonstrates the property of complete mediation as a condition for execution a command.


\HOLThmTag{ssm}{TR_exec_cmd_rule}\HOLssmTheoremsTRXXexecXXcmdXXrule

This is similar to rule0.  It adds the following as a premise for concluding rule0.

\HOLTokenTurnstile{} 
\HOLSymConst{\HOLTokenForall{}}\HOLBoundVar{elementTest} \HOLBoundVar{context} \HOLBoundVar{stateInterp} \HOLBoundVar{x} \HOLBoundVar{ins} \HOLBoundVar{s} \HOLBoundVar{outs}.\\
\hspace{0.5cm}(\HOLSymConst{\HOLTokenForall{}}\HOLBoundVar{M} \HOLBoundVar{Oi} \HOLBoundVar{Os}.\\
\hspace{0.9cm}\HOLConst{CFGInterpret} (\HOLBoundVar{M}\HOLSymConst{,}\HOLBoundVar{Oi}\HOLSymConst{,}\HOLBoundVar{Os})\\
\hspace{1.1cm}(\HOLConst{CFG} 
\HOLBoundVar{elementTest} 
\HOLBoundVar{stateInterp} 
\HOLBoundVar{context} 
(\HOLBoundVar{x}\HOLSymConst{::}\HOLBoundVar{ins}) 
\HOLBoundVar{s}
\HOLBoundVar{outs}) \\
\HOLSymConst{\HOLTokenImp{}}(\HOLBoundVar{M}\HOLSymConst{,}\HOLBoundVar{Oi}\HOLSymConst{,}\HOLBoundVar{Os}) \HOLConst{satList} \HOLConst{propCommandList} \HOLBoundVar{x}) \\

This part requires that the propCommandList applied to the inputList satisfies the Kripke structure.

\paragraph*{TR_trap_cmd_rule}
TR_trap_cmd_rule is similar to TR_exec_cmd_rule. 

\HOLThmTag{ssm}{TR_trap_cmd_rule}\HOLssmTheoremsTRXXtrapXXcmdXXrule

The difference is that instead of requiring propCommandList to satisfy the Kripke structure, it must satisfy NONE.  

\HOLTokenTurnstile{} 
\HOLSymConst{\HOLTokenForall{}}\HOLBoundVar{elementTest} \HOLBoundVar{context} \HOLBoundVar{stateInterp} \HOLBoundVar{x} \HOLBoundVar{ins} \HOLBoundVar{s} \HOLBoundVar{outs}.\\
\hspace{0.5cm} (\HOLSymConst{\HOLTokenForall{}}\HOLBoundVar{M} \HOLBoundVar{Oi} \HOLBoundVar{Os}.\\
\hspace{0.9cm}\HOLConst{CFGInterpret} (\HOLBoundVar{M}\HOLSymConst{,}\HOLBoundVar{Oi}\HOLSymConst{,}\HOLBoundVar{Os})\\
\hspace{1.1cm}(\HOLConst{CFG} 
\HOLBoundVar{elementTest} 
\HOLBoundVar{stateInterp} 
\HOLBoundVar{context} 
(\HOLBoundVar{x}\HOLSymConst{::}\HOLBoundVar{ins}) 
\HOLBoundVar{s}
\HOLBoundVar{outs}) \\
\HOLSymConst{\HOLTokenImp{}} (\HOLBoundVar{M}\HOLSymConst{,}\HOLBoundVar{Oi}\HOLSymConst{,}\HOLBoundVar{Os}) \HOLConst{sat} \HOLConst{prop} \HOLConst{NONE}) 



\paragraph*{TR_discard_cmd_rule}
This is the same as rule2 because the \textit{discard} transition type does not require configuration interpretation.


The next chapter demonstrates the parametrizable ssm applied to specific patrol base operations \glsentryshortpl{ssm}.
\end{document}